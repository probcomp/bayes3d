# AUTOGENERATED! DO NOT EDIT! File to edit: ../../scripts/_mkl/notebooks/00 - Utils.ipynb.

# %% auto 0
__all__ = ['key', 'logsumexp', 'cls', 'keysplit', 'bounding_box', 'argmax_axes', 'cam_to_screen', 'screen_to_cam', 'rot2d',
           'pack_2dpose', 'apply_2dpose', 'unit_vec', 'adjust_angle', 'argdiffs', 'Args', 'genjax_sample',
           'deff_gen_func_call', 'deff_gen_func_logpdf']

# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 2
import matplotlib.pyplot as plt
from   matplotlib.collections import LineCollection
import numpy as np
import jax
import jax.numpy as jnp
import genjax
from   genjax._src.core.transforms.incremental import UnknownChange, NoChange, Diff

# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 4
key       = jax.random.PRNGKey(0)
logsumexp = jax.scipy.special.logsumexp

# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 5
def keysplit(key, *ns):
    if len(ns) == 0:  
        return jax.random.split(key, 1)[0]
    elif len(ns) == 1:
        n, = ns
        if n == 1: return keysplit(key)
        else:      return jax.random.split(key, ns[0])
    else:
        keys = []
        for n in ns: keys.append(keysplit(key, n))
        return keys


# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 7
def bounding_box(arr, pad=0):
    """Takes a euclidean-like arr (`arr.shape[-1] == 2`) and returns its bounding box."""
    return jnp.array([
        [jnp.min(arr[...,0])-pad, jnp.min(arr[...,1])-pad],
        [jnp.max(arr[...,0])+pad, jnp.max(arr[...,1])+pad]
    ])

# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 8
def argmax_axes(a, axes=None):
    """Argmax along specified axes"""
    if axes is None: return jnp.argmax(a)
    
    n = len(axes)        
    axes_  = set(range(a.ndim))
    axes_0 = axes
    axes_1 = sorted(axes_ - set(axes_0))    
    axes_  = axes_0 + axes_1

    b = jnp.transpose(a, axes=axes_)
    c = b.reshape(np.prod(b.shape[:n]), -1)

    I = jnp.argmax(c, axis=0)
    I = jnp.array([jnp.unravel_index(i, b.shape[:n]) for i in I]).reshape(b.shape[n:] + (n,))

    return  I

# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 11
def cam_to_screen(x): return jnp.array([x[0]/x[2], x[1]/x[2], jnp.linalg.norm(x)])
def screen_to_cam(y): return y[2]*jnp.array([y[0], y[1], 1.0])

# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 12
def rot2d(hd): return jnp.array([
    [jnp.cos(hd), -jnp.sin(hd)], 
    [jnp.sin(hd),  jnp.cos(hd)]
    ]);

def pack_2dpose(x,hd): 
    return jnp.concatenate([x,jnp.array([hd])])

def apply_2dpose(p, ys): 
    return ys@rot2d(p[2] - jnp.pi/2).T + p[:2]

def unit_vec(hd): 
    return jnp.array([jnp.cos(hd), jnp.sin(hd)])

def adjust_angle(hd):
    """Adjusts angle to lie in the interval [-pi,pi)."""
    return (hd + jnp.pi)%(2*jnp.pi) - jnp.pi

# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 14
def argdiffs(args, other=None):
    return tuple(map(lambda v: Diff(v, UnknownChange), args))


# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 15
from builtins import property as _property, tuple as _tuple
from typing import Any


class Args(tuple):
    def __new__(cls, *args, **kwargs):
        return _tuple.__new__(cls, list(args) + list(kwargs.values()))
    
    def __init__(self, *args, **kwargs):
        self._d = dict()
        for k,v in kwargs.items():
            self._d[k] = v
            setattr(self, k, v)

    def __getitem__(self, k: str) -> Any:
        return self._d[k]

# %% ../../scripts/_mkl/notebooks/00 - Utils.ipynb 17
# 
# Monkey patching `sample` for `BuiltinGenerativeFunction`
# 
cls = genjax._src.generative_functions.builtin.builtin_gen_fn.BuiltinGenerativeFunction

def genjax_sample(self, key, *args, **kwargs):
    tr = self.simulate(key, args)
    return tr.get_retval()

setattr(cls, "sample", genjax_sample)


# 
# Monkey patching `sample` for `DeferredGenerativeFunctionCall`
# 
cls = genjax._src.generative_functions.builtin.builtin_gen_fn.DeferredGenerativeFunctionCall

def deff_gen_func_call(self, key, **kwargs):
    return self.gen_fn.sample(key, *self.args, **kwargs)

def deff_gen_func_logpdf(self, x, **kwargs):
    return self.gen_fn.logpdf(x, *self.args, **kwargs)

setattr(cls, "__call__", deff_gen_func_call)
setattr(cls, "sample", deff_gen_func_call)
setattr(cls, "logpdf", deff_gen_func_logpdf)
