# AUTOGENERATED! DO NOT EDIT! File to edit: ../../scripts/_mkl/notebooks/00b - Utils.ipynb.

# %% auto 0
__all__ = [
    "key",
    "logsumexp",
    "cls",
    "keysplit",
    "bounding_box",
    "argmax_axes",
    "cam_to_screen",
    "screen_to_cam",
    "rot2d",
    "pack_2dpose",
    "apply_2dpose",
    "unit_vec",
    "adjust_angle",
    "argdiffs",
    "Args",
    "genjax_sample",
    "deff_gen_func_call",
    "deff_gen_func_logpdf",
]

# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 2
import genjax
import jax
import jax.numpy as jnp
import numpy as np

# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 4
key = jax.random.PRNGKey(0)
logsumexp = jax.scipy.special.logsumexp


# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 5
def keysplit(key, *ns):
    if len(ns) == 0:
        return jax.random.split(key, 1)[0]
    elif len(ns) == 1:
        (n,) = ns
        if n == 1:
            return keysplit(key)
        else:
            return jax.random.split(key, ns[0])
    else:
        keys = []
        for n in ns:
            keys.append(keysplit(key, n))
        return keys


# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 7
def bounding_box(arr, pad=0):
    """Takes a euclidean-like arr (`arr.shape[-1] == 2`) and returns its bounding box."""
    return jnp.array(
        [
            [jnp.min(arr[..., 0]) - pad, jnp.min(arr[..., 1]) - pad],
            [jnp.max(arr[..., 0]) + pad, jnp.max(arr[..., 1]) + pad],
        ]
    )


# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 8
def argmax_axes(a, axes=None):
    """Argmax along specified axes"""
    if axes is None:
        return jnp.argmax(a)

    n = len(axes)
    axes_ = set(range(a.ndim))
    axes_0 = axes
    axes_1 = sorted(axes_ - set(axes_0))
    axes_ = axes_0 + axes_1

    b = jnp.transpose(a, axes=axes_)
    c = b.reshape(np.prod(b.shape[:n]), -1)

    I = jnp.argmax(c, axis=0)
    I = jnp.array([jnp.unravel_index(i, b.shape[:n]) for i in I]).reshape(
        b.shape[n:] + (n,)
    )

    return I


# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 11
def cam_to_screen(x):
    return jnp.array([x[0] / x[2], x[1] / x[2], jnp.linalg.norm(x)])


def screen_to_cam(y):
    return y[2] * jnp.array([y[0], y[1], 1.0])


# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 12
def rot2d(hd):
    return jnp.array([[jnp.cos(hd), -jnp.sin(hd)], [jnp.sin(hd), jnp.cos(hd)]])


def pack_2dpose(x, hd):
    return jnp.concatenate([x, jnp.array([hd])])


def apply_2dpose(p, ys):
    return ys @ rot2d(p[2] - jnp.pi / 2).T + p[:2]


def unit_vec(hd):
    return jnp.array([jnp.cos(hd), jnp.sin(hd)])


def adjust_angle(hd):
    """Adjusts angle to lie in the interval [-pi,pi)."""
    return (hd + jnp.pi) % (2 * jnp.pi) - jnp.pi


# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 14
from genjax.incremental import Diff, UnknownChange


def argdiffs(args, other=None):
    return tuple(map(lambda v: Diff(v, UnknownChange), args))


# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 15
from builtins import tuple as _tuple
from typing import Any


class Args(tuple):
    def __new__(cls, *args, **kwargs):
        return _tuple.__new__(cls, list(args) + list(kwargs.values()))

    def __init__(self, *args, **kwargs):
        self._d = dict()
        for k, v in kwargs.items():
            self._d[k] = v
            setattr(self, k, v)

    def __getitem__(self, k: str) -> Any:
        return self._d[k]


# %% ../../scripts/_mkl/notebooks/00b - Utils.ipynb 17
#
# Monkey patching `sample` for `BuiltinGenerativeFunction`
#
cls = genjax._src.generative_functions.static.static_gen_fn.StaticGenerativeFunction


def genjax_sample(self, key, *args, **kwargs):
    tr = self.simulate(key, args)
    return tr.get_retval()


setattr(cls, "sample", genjax_sample)


#
# Monkey patching `sample` for `DeferredGenerativeFunctionCall`
#
cls = genjax._src.generative_functions.supports_callees.SugaredGenerativeFunctionCall


def deff_gen_func_call(self, key, **kwargs):
    return self.gen_fn.sample(key, *self.args, **kwargs)


def deff_gen_func_logpdf(self, x, **kwargs):
    return self.gen_fn.logpdf(x, *self.args, **kwargs)


setattr(cls, "__call__", deff_gen_func_call)
setattr(cls, "sample", deff_gen_func_call)
setattr(cls, "logpdf", deff_gen_func_logpdf)
