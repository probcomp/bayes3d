# AUTOGENERATED! DO NOT EDIT! File to edit: ../../scripts/_mkl/notebooks/02 - Pose.ipynb.

# %% auto 0
__all__ = [
    "PI",
    "TWOPI",
    "CAM_ALONG_X",
    "Rot",
    "Pose",
    "rot2d",
    "pack_2dpose",
    "apply_2dpose",
    "unit_vec",
    "adjust_angle",
    "rot_x",
    "rot_y",
    "rot_z",
    "from_euler",
    "look_at",
    "ax_to_ind",
    "Rotation",
    "unpack_pose",
    "pack_pose",
    "apply_pose",
    "mpl_plot_pose",
    "lift_pose",
]

# %% ../../scripts/_mkl/notebooks/02 - Pose.ipynb 2
from collections import namedtuple

import jax.numpy as jnp
from plum import dispatch

PI = jnp.pi
TWOPI = 2 * PI


# %% ../../scripts/_mkl/notebooks/02 - Pose.ipynb 6
def rot2d(hd):
    return jnp.array([[jnp.cos(hd), -jnp.sin(hd)], [jnp.sin(hd), jnp.cos(hd)]])


def pack_2dpose(x, hd):
    return jnp.concatenate([x, jnp.array([hd])])


def apply_2dpose(p, ys):
    return ys @ rot2d(p[2] - jnp.pi / 2).T + p[:2]


def unit_vec(hd):
    return jnp.array([jnp.cos(hd), jnp.sin(hd)])


def adjust_angle(hd):
    return (hd + jnp.pi) % (2 * jnp.pi) - jnp.pi


# %% ../../scripts/_mkl/notebooks/02 - Pose.ipynb 8
CAM_ALONG_X = jnp.array([[0, 0, 1], [-1, 0, 0], [0, -1, 0]])


def rot_x(theta):
    return jnp.array(
        [
            [1, 0, 0],
            [0, jnp.cos(theta), -jnp.sin(theta)],
            [0, jnp.sin(theta), jnp.cos(theta)],
        ]
    )


def rot_y(theta):
    return jnp.array(
        [
            [jnp.cos(theta), 0, -jnp.sin(theta)],
            [0, 1, 0],
            [jnp.sin(theta), 0, jnp.cos(theta)],
        ]
    )


def rot_z(theta):
    return jnp.array(
        [
            [jnp.cos(theta), -jnp.sin(theta), 0],
            [jnp.sin(theta), jnp.cos(theta), 0],
            [0, 0, 1],
        ]
    )


def from_euler(rot, pitch=0.0, roll=0.0):
    """
    Imagine you stand on xy-plane and rotate (z-axis), pitch (y'-axis), and roll (x''-axis).
    """
    return rot_z(rot) @ rot_y(pitch) @ rot_x(roll)


def look_at(v, roll=0.0, cam=True):
    """Imagine you stand on xy-plane and point a camera at a point v in 3d space."""
    R = CAM_ALONG_X if cam else jnp.eye(3)

    n = jnp.linalg.norm(v)
    rot = jnp.arctan2(v[1], v[0])
    pitch = jnp.arctan2(v[2], n)
    return from_euler(rot, pitch, roll) @ R


# %% ../../scripts/_mkl/notebooks/02 - Pose.ipynb 9
def ax_to_ind(c):
    lookup = {"x": 0, "y": 1, "z": 2}
    return lookup[c]


class Rotation(object):
    @staticmethod
    def _x(theta):
        return jnp.array(
            [
                [1, 0, 0],
                [0, jnp.cos(theta), -jnp.sin(theta)],
                [0, jnp.sin(theta), jnp.cos(theta)],
            ]
        )

    @staticmethod
    def _y(theta):
        return jnp.array(
            [
                [jnp.cos(theta), 0, -jnp.sin(theta)],
                [0, 1, 0],
                [jnp.sin(theta), 0, jnp.cos(theta)],
            ]
        )

    @staticmethod
    def _z(theta):
        return jnp.array(
            [
                [jnp.cos(theta), -jnp.sin(theta), 0],
                [jnp.sin(theta), jnp.cos(theta), 0],
                [0, 0, 1],
            ]
        )

    @staticmethod
    def _ax(ax: str, theta):
        if ax == "x":
            return Rotation._x(theta)
        elif ax == "y":
            return Rotation._y(theta)
        elif ax == "z":
            return Rotation._z(theta)

    @staticmethod
    def from_euler(order, angles):
        """
        Args:
            order  : String of length 3, e.g. "xyz"
            angles : Array of length 3, e.g. [0, 0, 0]
        """
        rot_ax = Rotation._ax
        return (
            rot_ax(order[0], angles[0])
            @ rot_ax(order[1], angles[1])
            @ rot_ax(order[2], angles[2])
        )

    @staticmethod
    def look_at(v, roll=0.0, order="zyx"):
        """ """
        n = jnp.linalg.norm(v)
        rot = jnp.arctan2(v[1], v[0])
        pitch = jnp.arctan2(v[2], n)
        return Rotation.from_euler(order, [rot, pitch, roll]) @ yzX[:3, :3]


Rot = Rotation


# %% ../../scripts/_mkl/notebooks/02 - Pose.ipynb 12
Pose = namedtuple("Pose", ["x", "r"])


@dispatch
def unpack_pose(p: Pose):
    return p.x, p.r


@dispatch
def unpack_pose(R: jnp.ndarray):
    return R[:3, 3], R[:3, :3]


def pack_pose(x, r):
    return jnp.concatenate(
        [jnp.concatenate([r, x[:, None]], axis=1), jnp.array([[0, 0, 0, 1]])], axis=0
    )


def apply_pose(p, x):
    t, r = unpack_pose(p)
    return x @ r.T + t


# %% ../../scripts/_mkl/notebooks/02 - Pose.ipynb 13


def mpl_plot_pose(ax, p, s=0.1, length=0.1, normalize=True, **kwargs):
    t, r = unpack_pose(p)
    # Coordinate frame data
    origin = t
    x_axis = s * r[:3, 0]
    y_axis = s * r[:3, 1]
    z_axis = s * r[:3, 2]

    # Plotting the coordinate frame
    ax.quiver(
        *origin,
        *x_axis,
        color="r",
        label="X-axis",
        length=length,
        normalize=normalize,
        **kwargs,
    )
    ax.quiver(
        *origin,
        *y_axis,
        color="g",
        label="Y-axis",
        length=length,
        normalize=normalize,
        **kwargs,
    )
    ax.quiver(
        *origin,
        *z_axis,
        color="b",
        label="Z-axis",
        length=length,
        normalize=normalize,
        **kwargs,
    )


# %% ../../scripts/_mkl/notebooks/02 - Pose.ipynb 15
def lift_pose(x, hd, z=0.0, pitch=0.0, roll=0.0):
    """Lifts a 2d pose (x,hd) to 3d"""
    return pack_pose(jnp.concatenate([x, jnp.array([z])]), from_euler(hd) @ CAM_ALONG_X)
