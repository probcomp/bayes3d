<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>bayes3d.viz.viz API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bayes3d.viz.viz</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PIL import Image, ImageDraw, ImageFont
import numpy as np
import os
from PIL import Image
import numpy as np
import bayes3d.utils
import matplotlib.pyplot as plt
import matplotlib
import graphviz
import distinctipy
import jax.numpy as jnp

RED = np.array([1.0, 0.0, 0.0])
GREEN = np.array([0.0, 1.0, 0.0])
BLUE = np.array([0.0, 0.0, 1.0])
BLACK = np.array([0.0, 0.0, 0.0])

def make_gif_from_pil_images(images, filename):
    &#34;&#34;&#34;Save a list of PIL images as a GIF.
    
    Args:
        images (list): List of PIL images.
        filename (str): Filename to save GIF to.
    &#34;&#34;&#34;
    images[0].save(
        fp=filename,
        format=&#34;GIF&#34;,
        append_images=images,
        save_all=True,
        duration=100,
        loop=0,
    )

def load_image_from_file(filename):
    &#34;&#34;&#34;Load an image from a file.&#34;&#34;&#34;
    return Image(filename)

def get_depth_image(image, min=None, max=None, cmap=None):
    &#34;&#34;&#34;Convert a depth image to a PIL image.
    
    Args:
        image (np.ndarray): Depth image. Shape (H, W).
        min (float): Minimum depth value for colormap.
        max (float): Maximum depth value for colormap.
        cmap (matplotlib.colors.Colormap): Colormap to use.
    Returns:
        PIL.Image: Depth image visualized as a PIL image.
    &#34;&#34;&#34;
    if cmap is None:
        cmap = plt.get_cmap(&#39;turbo&#39;)
    if min is None:
        min = np.min(image)
    if max is None:
        max = np.max(image)
        
    depth = (image - min) / (max - min + 1e-10)
    depth = np.clip(depth, 0, 1)

    img = Image.fromarray(
        np.rint(cmap(depth) * 255.0).astype(np.int8), mode=&#34;RGBA&#34;
    )
    return img.convert(&#34;RGB&#34;)

def get_rgb_image(image, max=255.0):
    &#34;&#34;&#34;Convert an RGB image to a PIL image.
    
    Args:
        image (np.ndarray): RGB image. Shape (H, W, 3).
        max (float): Maximum value for colormap.
    Returns:
        PIL.Image: RGB image visualized as a PIL image.
    &#34;&#34;&#34;
    if image.shape[-1] == 3:
        image_type = &#34;RGB&#34;
    else:
        image_type = &#34;RGBA&#34;

    img = Image.fromarray(
        np.rint(
            image / max * 255.0
        ).astype(np.int8),
        mode=image_type,
    ).convert(&#34;RGB&#34;)
    return img

def add_rgba_dimension(image):
    &#34;&#34;&#34;Add an alpha channel to a particle image if it doesn&#39;t already have one.
    
    Args:
        image (np.ndarray): Particle image. Shape (H, W, 3) or (H, W, 4).
    &#34;&#34;&#34;
    if image.shape[-1] == 3:
        p = jnp.concatenate([image, 255.0 * jnp.ones((*image.shape[:2],1))],axis=-1)
        return p
    return image

def overlay_image(img_1, img_2, alpha=0.5):
    &#34;&#34;&#34;Overlay two images.
    
    Args:
        img_1 (PIL.Image): First image.
        img_2 (PIL.Image): Second image.
        alpha (float): Alpha value for blending.
    Returns:
        PIL.Image: Overlayed image.
    &#34;&#34;&#34;
    return Image.blend(img_1, img_2, alpha=alpha)

def resize_image(img, h, w):
    &#34;&#34;&#34;Resize an image.

    Args:
        img (PIL.Image): Image to resize.
        h (int): Height of resized image.
        w (int): Width of resized image.
    Returns:
        PIL.Image: Resized image.
    &#34;&#34;&#34;
    return img.resize((w, h))

def scale_image(img, factor):
    &#34;&#34;&#34;Scale an image.
    
    Args:
        img (PIL.Image): Image to scale.
        factor (float): Scale factor.
    Returns:
        PIL.Image: Scaled image.
    &#34;&#34;&#34;
    w,h = img.size
    return img.resize((int(w * factor), int(h * factor)))

def vstack_images(images, border = 10):
    &#34;&#34;&#34;Stack images vertically.

    Args:
        images (list): List of PIL images.
        border (int): Border between images.
    Returns:
        PIL.Image: Stacked image.
    &#34;&#34;&#34;
    max_w = 0
    sum_h = (len(images)-1)*border
    for img in images:
        w,h = img.size
        max_w = max(max_w, w)
        sum_h += h

    full_image = Image.new(&#39;RGB&#39;, (max_w, sum_h), (255, 255, 255))
    running_h = 0
    for img in images:
        w,h = img.size
        full_image.paste(img, (int(max_w/2 - w/2), running_h))
        running_h += h + border
    return full_image

def hstack_images(images, border = 10):
    &#34;&#34;&#34;Stack images horizontally.

    Args:
        images (list): List of PIL images.
        border (int): Border between images.
    Returns:
        PIL.Image: Stacked image.
    &#34;&#34;&#34;
    max_h = 0
    sum_w = (len(images)-1)*border
    for img in images:
        w,h = img.size
        max_h = max(max_h, h)
        sum_w += w

    full_image = Image.new(&#39;RGB&#39;, (sum_w, max_h),(255, 255, 255))
    running_w = 0
    for img in images:
        w,h = img.size
        full_image.paste(img, (running_w, int(max_h/2 - h/2)))
        running_w += w + border
    return full_image

def hvstack_images(images, h, w, border=10):
    &#34;&#34;&#34;Stack images in a grid.

    Args:
        images (list): List of PIL images.
        h (int): Number of rows.
        w (int): Number of columns.
        border (int): Border between images.
    Returns:
        PIL.Image: Stacked image. 
    &#34;&#34;&#34;
    assert len(images) == h * w

    images_to_vstack = []

    for row_idx in range(h):
        hstacked_row = hstack_images(images[row_idx*w:(row_idx+1)*w])
        images_to_vstack.append(hstacked_row)
    
    return vstack_images(images_to_vstack)

def multi_panel(images, labels=None, title=None, bottom_text=None, title_fontsize=40, label_fontsize=30,  bottom_fontsize=20, middle_width=10):
    &#34;&#34;&#34;Combine multiple images into a single image.
    
    Args:
        images (list): List of PIL images.
        labels (list): List of labels for each image.
        title (str): Title for image.
        bottom_text (str): Text for bottom of image.
        title_fontsize (int): Font size for title.
        label_fontsize (int): Font size for labels.
        bottom_fontsize (int): Font size for bottom text.
        middle_width (int): Width of border between images.
    Returns:
        PIL.Image: Combined image.
    &#34;&#34;&#34;
    num_images = len(images)
    w = images[0].width
    h = images[0].height

    sum_of_widths = np.sum([img.width for img in images])

    dst = Image.new(
        &#34;RGBA&#34;, (sum_of_widths + (num_images - 1) * middle_width, h), (255, 255, 255, 255)
    )

    drawer = ImageDraw.Draw(dst)
    font_bottom = ImageFont.truetype(os.path.join(bayes3d.utils.get_assets_dir(), &#34;fonts&#34;, &#34;IBMPlexSerif-Regular.ttf&#34;), bottom_fontsize)
    font_label = ImageFont.truetype(os.path.join(bayes3d.utils.get_assets_dir(), &#34;fonts&#34;, &#34;IBMPlexSerif-Regular.ttf&#34;), label_fontsize)
    font_title = ImageFont.truetype(os.path.join(bayes3d.utils.get_assets_dir(), &#34;fonts&#34;, &#34;IBMPlexSerif-Regular.ttf&#34;), title_fontsize)

    bottom_border = 0
    title_border = 0
    label_border = 0
    if bottom_text is not None:
        msg = bottom_text
        _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_bottom)
        bottom_border = text_h
    if title is not None:
        msg = title
        _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_title)
        title_border = text_h
    if labels is not None:
        for msg in labels:
            _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_label)
            label_border = max(text_h, label_border)

    bottom_border += 0 
    title_border += 20
    label_border += 20 

    dst = Image.new(
        &#34;RGBA&#34;, (sum_of_widths+ (num_images - 1) * middle_width, h + title_border + label_border + bottom_border), (255, 255, 255, 255)
    )
    drawer = ImageDraw.Draw(dst)

    width_counter = 0
    for (j, img) in enumerate(images):
        dst.paste(
            img,
            (width_counter + j * middle_width, title_border + label_border)
        )
        width_counter += img.width

    if title is not None:
        msg = title
        _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_title)
        drawer.text(((sum_of_widths + (num_images - 1) * middle_width)/2.0 - text_w/2 , title_border/2 - text_h/2), msg, font=font_title, fill=&#34;black&#34;)


    width_counter = 0
    if labels is not None:
        for (i, msg) in enumerate(labels):
            w = images[i].width
            _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_label)
            drawer.text((width_counter + i * middle_width + w/2 - text_w/2, title_border + label_border/2 - text_h/2), msg, font=font_label, fill=&#34;black&#34;)
            width_counter += w

    if bottom_text is not None:
        msg = bottom_text
        _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_bottom)
        drawer.text((5,  title_border + label_border + h + 5), msg, font=font_bottom, fill=&#34;black&#34;)

    return dst

def distinct_colors(num_colors, pastel_factor=0.5):
    &#34;&#34;&#34;Get a list of distinct colors.
    
    Args:
        num_colors (int): Number of colors to generate.
        pastel_factor (float): Pastel factor.
    Returns:
        list: List of colors.
    &#34;&#34;&#34;
    return [np.array(i) for i in distinctipy.get_colors(num_colors, pastel_factor=pastel_factor)]

def viz_graph(num_nodes, edges, filename, node_names=None):
    &#34;&#34;&#34;Visualize a graph.
    
    Args:
        num_nodes (int): Number of nodes in graph.
        edges (list): List of edges in graph.
        filename (str): Filename to save graph to.
        node_names (list): List of node names.
    &#34;&#34;&#34;
    if node_names is None:
        node_names = [str(i) for i in range(num_nodes)]

    g_out = graphviz.Digraph()
    g_out.attr(&#34;node&#34;, style=&#34;filled&#34;)
    
    colors = matplotlib.cm.tab20(range(num_nodes))
    colors = distinctipy.get_colors(num_nodes, pastel_factor=0.7)
    for i in range(num_nodes):
        g_out.node(str(i), node_names[i], fillcolor=matplotlib.colors.to_hex(colors[i]))

    for (i,j) in edges:
        if i==-1:
            continue
        g_out.edge(str(i),str(j))

    max_width_px = 2000
    max_height_px = 2000
    dpi = 200

    g_out.attr(&#34;graph&#34;,
                # See https://graphviz.gitlab.io/_pages/doc/info/attrs.html#a:size
                size=&#34;{},{}!&#34;.format(max_width_px / dpi, max_height_px / dpi),
                dpi=str(dpi))
    filename_prefix, filetype = filename.split(&#34;.&#34;)
    g_out.render(filename_prefix, format=filetype)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bayes3d.viz.viz.add_rgba_dimension"><code class="name flex">
<span>def <span class="ident">add_rgba_dimension</span></span>(<span>image)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an alpha channel to a particle image if it doesn't already have one.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Particle image. Shape (H, W, 3) or (H, W, 4).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_rgba_dimension(image):
    &#34;&#34;&#34;Add an alpha channel to a particle image if it doesn&#39;t already have one.
    
    Args:
        image (np.ndarray): Particle image. Shape (H, W, 3) or (H, W, 4).
    &#34;&#34;&#34;
    if image.shape[-1] == 3:
        p = jnp.concatenate([image, 255.0 * jnp.ones((*image.shape[:2],1))],axis=-1)
        return p
    return image</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.distinct_colors"><code class="name flex">
<span>def <span class="ident">distinct_colors</span></span>(<span>num_colors, pastel_factor=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of distinct colors.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_colors</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of colors to generate.</dd>
<dt><strong><code>pastel_factor</code></strong> :&ensp;<code>float</code></dt>
<dd>Pastel factor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of colors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distinct_colors(num_colors, pastel_factor=0.5):
    &#34;&#34;&#34;Get a list of distinct colors.
    
    Args:
        num_colors (int): Number of colors to generate.
        pastel_factor (float): Pastel factor.
    Returns:
        list: List of colors.
    &#34;&#34;&#34;
    return [np.array(i) for i in distinctipy.get_colors(num_colors, pastel_factor=pastel_factor)]</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.get_depth_image"><code class="name flex">
<span>def <span class="ident">get_depth_image</span></span>(<span>image, min=None, max=None, cmap=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a depth image to a PIL image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Depth image. Shape (H, W).</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum depth value for colormap.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum depth value for colormap.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>matplotlib.colors.Colormap</code></dt>
<dd>Colormap to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>Depth image visualized as a PIL image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_depth_image(image, min=None, max=None, cmap=None):
    &#34;&#34;&#34;Convert a depth image to a PIL image.
    
    Args:
        image (np.ndarray): Depth image. Shape (H, W).
        min (float): Minimum depth value for colormap.
        max (float): Maximum depth value for colormap.
        cmap (matplotlib.colors.Colormap): Colormap to use.
    Returns:
        PIL.Image: Depth image visualized as a PIL image.
    &#34;&#34;&#34;
    if cmap is None:
        cmap = plt.get_cmap(&#39;turbo&#39;)
    if min is None:
        min = np.min(image)
    if max is None:
        max = np.max(image)
        
    depth = (image - min) / (max - min + 1e-10)
    depth = np.clip(depth, 0, 1)

    img = Image.fromarray(
        np.rint(cmap(depth) * 255.0).astype(np.int8), mode=&#34;RGBA&#34;
    )
    return img.convert(&#34;RGB&#34;)</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.get_rgb_image"><code class="name flex">
<span>def <span class="ident">get_rgb_image</span></span>(<span>image, max=255.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an RGB image to a PIL image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>RGB image. Shape (H, W, 3).</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum value for colormap.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>RGB image visualized as a PIL image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rgb_image(image, max=255.0):
    &#34;&#34;&#34;Convert an RGB image to a PIL image.
    
    Args:
        image (np.ndarray): RGB image. Shape (H, W, 3).
        max (float): Maximum value for colormap.
    Returns:
        PIL.Image: RGB image visualized as a PIL image.
    &#34;&#34;&#34;
    if image.shape[-1] == 3:
        image_type = &#34;RGB&#34;
    else:
        image_type = &#34;RGBA&#34;

    img = Image.fromarray(
        np.rint(
            image / max * 255.0
        ).astype(np.int8),
        mode=image_type,
    ).convert(&#34;RGB&#34;)
    return img</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.hstack_images"><code class="name flex">
<span>def <span class="ident">hstack_images</span></span>(<span>images, border=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Stack images horizontally.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>list</code></dt>
<dd>List of PIL images.</dd>
<dt><strong><code>border</code></strong> :&ensp;<code>int</code></dt>
<dd>Border between images.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>Stacked image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hstack_images(images, border = 10):
    &#34;&#34;&#34;Stack images horizontally.

    Args:
        images (list): List of PIL images.
        border (int): Border between images.
    Returns:
        PIL.Image: Stacked image.
    &#34;&#34;&#34;
    max_h = 0
    sum_w = (len(images)-1)*border
    for img in images:
        w,h = img.size
        max_h = max(max_h, h)
        sum_w += w

    full_image = Image.new(&#39;RGB&#39;, (sum_w, max_h),(255, 255, 255))
    running_w = 0
    for img in images:
        w,h = img.size
        full_image.paste(img, (running_w, int(max_h/2 - h/2)))
        running_w += w + border
    return full_image</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.hvstack_images"><code class="name flex">
<span>def <span class="ident">hvstack_images</span></span>(<span>images, h, w, border=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Stack images in a grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>list</code></dt>
<dd>List of PIL images.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of rows.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of columns.</dd>
<dt><strong><code>border</code></strong> :&ensp;<code>int</code></dt>
<dd>Border between images.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>Stacked image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hvstack_images(images, h, w, border=10):
    &#34;&#34;&#34;Stack images in a grid.

    Args:
        images (list): List of PIL images.
        h (int): Number of rows.
        w (int): Number of columns.
        border (int): Border between images.
    Returns:
        PIL.Image: Stacked image. 
    &#34;&#34;&#34;
    assert len(images) == h * w

    images_to_vstack = []

    for row_idx in range(h):
        hstacked_row = hstack_images(images[row_idx*w:(row_idx+1)*w])
        images_to_vstack.append(hstacked_row)
    
    return vstack_images(images_to_vstack)</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.load_image_from_file"><code class="name flex">
<span>def <span class="ident">load_image_from_file</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load an image from a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_image_from_file(filename):
    &#34;&#34;&#34;Load an image from a file.&#34;&#34;&#34;
    return Image(filename)</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.make_gif_from_pil_images"><code class="name flex">
<span>def <span class="ident">make_gif_from_pil_images</span></span>(<span>images, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a list of PIL images as a GIF.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>list</code></dt>
<dd>List of PIL images.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save GIF to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_gif_from_pil_images(images, filename):
    &#34;&#34;&#34;Save a list of PIL images as a GIF.
    
    Args:
        images (list): List of PIL images.
        filename (str): Filename to save GIF to.
    &#34;&#34;&#34;
    images[0].save(
        fp=filename,
        format=&#34;GIF&#34;,
        append_images=images,
        save_all=True,
        duration=100,
        loop=0,
    )</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.multi_panel"><code class="name flex">
<span>def <span class="ident">multi_panel</span></span>(<span>images, labels=None, title=None, bottom_text=None, title_fontsize=40, label_fontsize=30, bottom_fontsize=20, middle_width=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine multiple images into a single image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>list</code></dt>
<dd>List of PIL images.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code></dt>
<dd>List of labels for each image.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>Title for image.</dd>
<dt><strong><code>bottom_text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text for bottom of image.</dd>
<dt><strong><code>title_fontsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Font size for title.</dd>
<dt><strong><code>label_fontsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Font size for labels.</dd>
<dt><strong><code>bottom_fontsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Font size for bottom text.</dd>
<dt><strong><code>middle_width</code></strong> :&ensp;<code>int</code></dt>
<dd>Width of border between images.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>Combined image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_panel(images, labels=None, title=None, bottom_text=None, title_fontsize=40, label_fontsize=30,  bottom_fontsize=20, middle_width=10):
    &#34;&#34;&#34;Combine multiple images into a single image.
    
    Args:
        images (list): List of PIL images.
        labels (list): List of labels for each image.
        title (str): Title for image.
        bottom_text (str): Text for bottom of image.
        title_fontsize (int): Font size for title.
        label_fontsize (int): Font size for labels.
        bottom_fontsize (int): Font size for bottom text.
        middle_width (int): Width of border between images.
    Returns:
        PIL.Image: Combined image.
    &#34;&#34;&#34;
    num_images = len(images)
    w = images[0].width
    h = images[0].height

    sum_of_widths = np.sum([img.width for img in images])

    dst = Image.new(
        &#34;RGBA&#34;, (sum_of_widths + (num_images - 1) * middle_width, h), (255, 255, 255, 255)
    )

    drawer = ImageDraw.Draw(dst)
    font_bottom = ImageFont.truetype(os.path.join(bayes3d.utils.get_assets_dir(), &#34;fonts&#34;, &#34;IBMPlexSerif-Regular.ttf&#34;), bottom_fontsize)
    font_label = ImageFont.truetype(os.path.join(bayes3d.utils.get_assets_dir(), &#34;fonts&#34;, &#34;IBMPlexSerif-Regular.ttf&#34;), label_fontsize)
    font_title = ImageFont.truetype(os.path.join(bayes3d.utils.get_assets_dir(), &#34;fonts&#34;, &#34;IBMPlexSerif-Regular.ttf&#34;), title_fontsize)

    bottom_border = 0
    title_border = 0
    label_border = 0
    if bottom_text is not None:
        msg = bottom_text
        _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_bottom)
        bottom_border = text_h
    if title is not None:
        msg = title
        _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_title)
        title_border = text_h
    if labels is not None:
        for msg in labels:
            _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_label)
            label_border = max(text_h, label_border)

    bottom_border += 0 
    title_border += 20
    label_border += 20 

    dst = Image.new(
        &#34;RGBA&#34;, (sum_of_widths+ (num_images - 1) * middle_width, h + title_border + label_border + bottom_border), (255, 255, 255, 255)
    )
    drawer = ImageDraw.Draw(dst)

    width_counter = 0
    for (j, img) in enumerate(images):
        dst.paste(
            img,
            (width_counter + j * middle_width, title_border + label_border)
        )
        width_counter += img.width

    if title is not None:
        msg = title
        _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_title)
        drawer.text(((sum_of_widths + (num_images - 1) * middle_width)/2.0 - text_w/2 , title_border/2 - text_h/2), msg, font=font_title, fill=&#34;black&#34;)


    width_counter = 0
    if labels is not None:
        for (i, msg) in enumerate(labels):
            w = images[i].width
            _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_label)
            drawer.text((width_counter + i * middle_width + w/2 - text_w/2, title_border + label_border/2 - text_h/2), msg, font=font_label, fill=&#34;black&#34;)
            width_counter += w

    if bottom_text is not None:
        msg = bottom_text
        _, _, text_w, text_h = drawer.textbbox((0, 0), msg, font=font_bottom)
        drawer.text((5,  title_border + label_border + h + 5), msg, font=font_bottom, fill=&#34;black&#34;)

    return dst</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.overlay_image"><code class="name flex">
<span>def <span class="ident">overlay_image</span></span>(<span>img_1, img_2, alpha=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Overlay two images.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>img_1</code></strong> :&ensp;<code>PIL.Image</code></dt>
<dd>First image.</dd>
<dt><strong><code>img_2</code></strong> :&ensp;<code>PIL.Image</code></dt>
<dd>Second image.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Alpha value for blending.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>Overlayed image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlay_image(img_1, img_2, alpha=0.5):
    &#34;&#34;&#34;Overlay two images.
    
    Args:
        img_1 (PIL.Image): First image.
        img_2 (PIL.Image): Second image.
        alpha (float): Alpha value for blending.
    Returns:
        PIL.Image: Overlayed image.
    &#34;&#34;&#34;
    return Image.blend(img_1, img_2, alpha=alpha)</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.resize_image"><code class="name flex">
<span>def <span class="ident">resize_image</span></span>(<span>img, h, w)</span>
</code></dt>
<dd>
<div class="desc"><p>Resize an image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>img</code></strong> :&ensp;<code>PIL.Image</code></dt>
<dd>Image to resize.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>int</code></dt>
<dd>Height of resized image.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>int</code></dt>
<dd>Width of resized image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>Resized image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_image(img, h, w):
    &#34;&#34;&#34;Resize an image.

    Args:
        img (PIL.Image): Image to resize.
        h (int): Height of resized image.
        w (int): Width of resized image.
    Returns:
        PIL.Image: Resized image.
    &#34;&#34;&#34;
    return img.resize((w, h))</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.scale_image"><code class="name flex">
<span>def <span class="ident">scale_image</span></span>(<span>img, factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale an image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>img</code></strong> :&ensp;<code>PIL.Image</code></dt>
<dd>Image to scale.</dd>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code></dt>
<dd>Scale factor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>Scaled image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_image(img, factor):
    &#34;&#34;&#34;Scale an image.
    
    Args:
        img (PIL.Image): Image to scale.
        factor (float): Scale factor.
    Returns:
        PIL.Image: Scaled image.
    &#34;&#34;&#34;
    w,h = img.size
    return img.resize((int(w * factor), int(h * factor)))</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.viz_graph"><code class="name flex">
<span>def <span class="ident">viz_graph</span></span>(<span>num_nodes, edges, filename, node_names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize a graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of nodes in graph.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>list</code></dt>
<dd>List of edges in graph.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save graph to.</dd>
<dt><strong><code>node_names</code></strong> :&ensp;<code>list</code></dt>
<dd>List of node names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz_graph(num_nodes, edges, filename, node_names=None):
    &#34;&#34;&#34;Visualize a graph.
    
    Args:
        num_nodes (int): Number of nodes in graph.
        edges (list): List of edges in graph.
        filename (str): Filename to save graph to.
        node_names (list): List of node names.
    &#34;&#34;&#34;
    if node_names is None:
        node_names = [str(i) for i in range(num_nodes)]

    g_out = graphviz.Digraph()
    g_out.attr(&#34;node&#34;, style=&#34;filled&#34;)
    
    colors = matplotlib.cm.tab20(range(num_nodes))
    colors = distinctipy.get_colors(num_nodes, pastel_factor=0.7)
    for i in range(num_nodes):
        g_out.node(str(i), node_names[i], fillcolor=matplotlib.colors.to_hex(colors[i]))

    for (i,j) in edges:
        if i==-1:
            continue
        g_out.edge(str(i),str(j))

    max_width_px = 2000
    max_height_px = 2000
    dpi = 200

    g_out.attr(&#34;graph&#34;,
                # See https://graphviz.gitlab.io/_pages/doc/info/attrs.html#a:size
                size=&#34;{},{}!&#34;.format(max_width_px / dpi, max_height_px / dpi),
                dpi=str(dpi))
    filename_prefix, filetype = filename.split(&#34;.&#34;)
    g_out.render(filename_prefix, format=filetype)</code></pre>
</details>
</dd>
<dt id="bayes3d.viz.viz.vstack_images"><code class="name flex">
<span>def <span class="ident">vstack_images</span></span>(<span>images, border=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Stack images vertically.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>list</code></dt>
<dd>List of PIL images.</dd>
<dt><strong><code>border</code></strong> :&ensp;<code>int</code></dt>
<dd>Border between images.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PIL.Image</code></dt>
<dd>Stacked image.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vstack_images(images, border = 10):
    &#34;&#34;&#34;Stack images vertically.

    Args:
        images (list): List of PIL images.
        border (int): Border between images.
    Returns:
        PIL.Image: Stacked image.
    &#34;&#34;&#34;
    max_w = 0
    sum_h = (len(images)-1)*border
    for img in images:
        w,h = img.size
        max_w = max(max_w, w)
        sum_h += h

    full_image = Image.new(&#39;RGB&#39;, (max_w, sum_h), (255, 255, 255))
    running_h = 0
    for img in images:
        w,h = img.size
        full_image.paste(img, (int(max_w/2 - w/2), running_h))
        running_h += h + border
    return full_image</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bayes3d.viz" href="index.html">bayes3d.viz</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bayes3d.viz.viz.add_rgba_dimension" href="#bayes3d.viz.viz.add_rgba_dimension">add_rgba_dimension</a></code></li>
<li><code><a title="bayes3d.viz.viz.distinct_colors" href="#bayes3d.viz.viz.distinct_colors">distinct_colors</a></code></li>
<li><code><a title="bayes3d.viz.viz.get_depth_image" href="#bayes3d.viz.viz.get_depth_image">get_depth_image</a></code></li>
<li><code><a title="bayes3d.viz.viz.get_rgb_image" href="#bayes3d.viz.viz.get_rgb_image">get_rgb_image</a></code></li>
<li><code><a title="bayes3d.viz.viz.hstack_images" href="#bayes3d.viz.viz.hstack_images">hstack_images</a></code></li>
<li><code><a title="bayes3d.viz.viz.hvstack_images" href="#bayes3d.viz.viz.hvstack_images">hvstack_images</a></code></li>
<li><code><a title="bayes3d.viz.viz.load_image_from_file" href="#bayes3d.viz.viz.load_image_from_file">load_image_from_file</a></code></li>
<li><code><a title="bayes3d.viz.viz.make_gif_from_pil_images" href="#bayes3d.viz.viz.make_gif_from_pil_images">make_gif_from_pil_images</a></code></li>
<li><code><a title="bayes3d.viz.viz.multi_panel" href="#bayes3d.viz.viz.multi_panel">multi_panel</a></code></li>
<li><code><a title="bayes3d.viz.viz.overlay_image" href="#bayes3d.viz.viz.overlay_image">overlay_image</a></code></li>
<li><code><a title="bayes3d.viz.viz.resize_image" href="#bayes3d.viz.viz.resize_image">resize_image</a></code></li>
<li><code><a title="bayes3d.viz.viz.scale_image" href="#bayes3d.viz.viz.scale_image">scale_image</a></code></li>
<li><code><a title="bayes3d.viz.viz.viz_graph" href="#bayes3d.viz.viz.viz_graph">viz_graph</a></code></li>
<li><code><a title="bayes3d.viz.viz.vstack_images" href="#bayes3d.viz.viz.vstack_images">vstack_images</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>